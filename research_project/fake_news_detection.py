# -*- coding: utf-8 -*-
"""Fake_News_Detection_4_Models

Automatically generated by Colaboratory.
"""

# Import the libraries
import re
import string
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report
from sklearn.feature_extraction.text import TfidfVectorizer

from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.ensemble import RandomForestClassifier

# Upload the datasets
from google.colab import files
files.upload()
files.upload()

# Load the two datasets

df_fake = pd.read_csv("fake_news.csv")
df_real = pd.read_csv("real_news.csv")

df_fake

df_real

# Set the class of the news (1 real, 0 fake)
df_fake['class'] = 0
df_real['class'] = 1

# Create a new dataframe that combines the previous ones
df = pd.concat([df_fake, df_real])
# Save the new dataframe
df.to_csv("mixed_news.csv")

df

# Drop the useless columns
df = df.drop(['title', 'subject', 'date'], axis=1)
# Random rearrange of the order
df = df.sample(frac=1)
# Show the data
df

# Reset the index
df.reset_index(inplace=True)
df

# Drop the "Index" column
df.drop(["index"], axis=1, inplace=True)
df

# Create a function that cleans the text
def clean_text(text):
	text = text.lower()
	text = re.sub('\[.*?\]', '', text)
	text = re.sub("\\W"," ",text)
	text = re.sub('https?://\S+|www\.\S+', '', text)
	text = re.sub('<.*?>+', '', text)
	text = re.sub('[%s]' % re.escape(string.punctuation), '', text)
	text = re.sub('\n', '', text)
	text = re.sub('\w*\d\w*', '', text)
	return text

# Clean the text
df['text'] = df['text'].apply(clean_text)
df

# Prepare the data

x = df["text"]
y = df["class"]

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)

# Vectorize the data
vectorization = TfidfVectorizer()
xv_train = vectorization.fit_transform(x_train)
xv_test = vectorization.transform(x_test)

"""#Logistic Regression"""

# Train the model
LR = LogisticRegression()
LR.fit(xv_train,y_train)

# Predict
pred_lr=LR.predict(xv_test)

# See the results
print(LR.score(xv_test, y_test))
print(classification_report(y_test, pred_lr))

"""#Decision Tree Classifier"""

# Train the model
DT = DecisionTreeClassifier()
DT.fit(xv_train, y_train)

# Predict
pred_dt = DT.predict(xv_test)

# See the results
print(DT.score(xv_test, y_test))
print(classification_report(y_test, pred_dt))

"""#Gradient Boosting Classifier"""

# Train the model
GBC = GradientBoostingClassifier(random_state=0)
GBC.fit(xv_train, y_train)

# Predict
pred_gbc = GBC.predict(xv_test)

# See the results
print(GBC.score(xv_test, y_test))
print(classification_report(y_test, pred_gbc))

"""#Random Forest Classifier"""

# Train the model
RFC = RandomForestClassifier(random_state=0)
RFC.fit(xv_train, y_train)

# Predict
pred_rfc = RFC.predict(xv_test)

# See the results
print(RFC.score(xv_test, y_test))
print(classification_report(y_test, pred_rfc))

"""#Manual Testing"""

# Create a function that converts the output label (0 or 1 to "Fake" or "Real")
def output_lablel(n):
	if n == 0:
		return "Fake News"
	if n == 1:
		return "Real News"

# Create a function that test the input news
def manual_testing(news):
	# Convert the news to a dataframe
	testing_news = {"text":[news]}
	new_def_test = pd.DataFrame(testing_news)
	# Clean the text
	new_def_test["text"] = new_def_test["text"].apply(clean_text)
	# Extract the output text
	new_x_test = new_def_test["text"]
	# Vectorize the input
	new_xv_test = vectorization.transform(new_x_test)
	# Predict with the four models
	pred_LR = LR.predict(new_xv_test)
	pred_DT = DT.predict(new_xv_test)
	pred_GBC = GBC.predict(new_xv_test)
	pred_RFC = RFC.predict(new_xv_test)
	# Prepare the output string
	result = "\n\nLR Prediction: {} ".format(output_lablel(pred_LR[0]))
	result += "\nDT Prediction: {} ".format(output_lablel(pred_DT[0]))
	result += "\nGBC Prediction: {} ".format(output_lablel(pred_GBC[0]))
	result += "\nRFC Prediction: {}".format(output_lablel(pred_RFC[0]))
	print(result)

# Manual test
news = input("Manual Test: ")
manual_testing(news)
